<!DOCTYPE html>
<html>
<head>
    <title>Custom Table Review System</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .review-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        .header {
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 15px;
            margin-bottom: 20px;
        }
        
        .title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        
        .progress {
            color: #666;
            font-size: 14px;
            margin-bottom: 15px;
        }
        
        .navigation {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .nav-btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 14px;
        }
        
        .nav-btn:hover {
            background: #f5f5f5;
        }
        
        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .current-table {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        
        .table-info {
            margin-bottom: 15px;
        }
        
        .table-hash {
            font-family: monospace;
            background: #e9ecef;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            color: #666;
            margin-left: 10px;
        }
        
        .context-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .context-item {
            background: white;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
        }
        
        .context-label {
            font-weight: 600;
            color: #555;
            margin-bottom: 5px;
        }
        
        .versions {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        .version-badge {
            background: #007bff;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
        }
        
        .pdf-links {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .pdf-link {
            color: #007bff;
            text-decoration: none;
            font-size: 12px;
        }
        
        .pdf-link:hover {
            text-decoration: underline;
        }
        
        .table-editor {
            border: 2px solid #007bff;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
            background: white;
        }
        
        .editor-header {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            gap: 15px;
        }
        
        .editor-controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 15px;
        }
        
        .editor-control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .editor-control-group label {
            font-size: 12px;
            color: #666;
            margin-right: 5px;
        }
        
        .compact-btn {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background: white;
            cursor: pointer;
            font-size: 11px;
            color: #666;
        }
        
        .compact-btn:hover {
            background: #f5f5f5;
            color: #333;
        }
        
        .compact-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .header-checkbox {
            display: flex;
            align-items: center;
            font-size: 12px;
            color: #666;
        }
        
        .header-checkbox input {
            margin-right: 5px;
        }
        
        .editor-title {
            font-size: 16px;
            font-weight: 600;
            color: #007bff;
        }
        
        
        .custom-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }
        
        .custom-table th,
        .custom-table td {
            border: 1px solid #ddd;
            padding: 6px 12px;
            text-align: left;
            vertical-align: top;
            min-width: 100px;
            min-height: 20px;
            height: 20px;
            line-height: 1.5;
        }
        
        .custom-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }
        
        .custom-table th.header-enabled {
            background: #e9ecef;
            border-color: #6c757d;
        }
        
        .custom-table th[contenteditable="true"]:focus {
            outline: 2px solid #007bff;
            outline-offset: -2px;
            background: #fff3cd;
        }
        
        .custom-table td {
            background: white;
        }
        
        .custom-table td[contenteditable="true"]:focus {
            outline: 2px solid #007bff;
            outline-offset: -2px;
            background: #fff3cd;
        }
        
        .custom-table td.modified {
            background: #d4edda;
            border-color: #28a745;
        }
        
        /* Ensure empty cells maintain height */
        .custom-table td:empty::after,
        .custom-table th:empty::after {
            content: '\00a0'; /* Non-breaking space */
            display: inline-block;
            min-height: 10px;
        }
        
        .table-status-control {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }
        
        .status-label {
            font-weight: 600;
            color: #495057;
            margin-bottom: 10px;
            display: block;
        }
        
        .radio-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        
        .radio-option {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #ddd;
            background: white;
            transition: all 0.2s;
            min-height: 45px;
            justify-content: center;
            flex: 1;
            min-width: 200px;
        }
        
        .radio-option-header {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }
        
        .radio-option:hover {
            background: #f5f5f5;
            border-color: #999;
        }
        
        .radio-option input[type="radio"] {
            margin-right: 8px;
            cursor: pointer;
        }
        
        .radio-option input[type="radio"]:checked + .radio-label {
            font-weight: 600;
        }
        
        .radio-option:has(input[value="undefined"]:checked) {
            background: #fff3cd;
            border-color: #ffeaa7;
        }
        
        .radio-option:has(input[value="confirmed_without_changes"]:checked) {
            background: #d4edda;
            border-color: #c3e6cb;
        }
        
        .radio-option:has(input[value="confirmed_with_changes"]:checked) {
            background: #cce5ff;
            border-color: #99ccff;
        }
        
        .radio-option:has(input[value="rejected"]:checked) {
            background: #f8d7da;
            border-color: #f5c6cb;
        }
        
        .radio-description {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
            font-style: italic;
            line-height: 1.2;
        }
        
        .radio-label {
            font-size: 14px;
            color: #333;
        }
        
        .table-configuration {
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }
        
        .config-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .config-item input[type="checkbox"] {
            cursor: pointer;
        }
        
        .selected-cell {
            background-color: #007bff !important;
            color: white !important;
            outline: 2px solid #0056b3 !important;
        }
        
        .table-operations {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 15px;
        }
        
        .operation-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }
        
        .operation-label {
            font-weight: 600;
            color: #555;
            font-size: 13px;
            min-width: 120px;
            margin-right: 10px;
        }
        
        .operation-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .btn-confirm {
            background: #28a745;
            color: white;
        }
        
        .btn-confirm:hover {
            background: #218838;
        }
        
        .btn-reject {
            background: #dc3545;
            color: white;
        }
        
        .btn-reject:hover {
            background: #c82333;
        }
        
        .btn-merge {
            background: #ffc107;
            color: #212529;
        }
        
        .btn-merge:hover {
            background: #e0a800;
        }
        
        .btn-skip {
            background: #6c757d;
            color: white;
        }
        
        .btn-skip:hover {
            background: #5a6268;
        }
        
        .status-display {
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            text-transform: uppercase;
            margin-left: auto;
        }
        
        .status-pending {
            background: #fff3cd;
            color: #856404;
        }
        
        .status-confirmed {
            background: #d4edda;
            color: #155724;
        }
        
        .status-rejected {
            background: #f8d7da;
            color: #721c24;
        }
        
        .status-edited {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .status-confirmed-without-changes {
            background: #d4edda;
            color: #155724;
        }
        
        .status-confirmed-with-changes {
            background: #cce5ff;
            color: #0066cc;
        }
        
        .status-merged {
            background: #e2e3e5;
            color: #383d41;
        }
        
        .btn-unmerge {
            background: #fd7e14;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }
        
        .btn-unmerge:hover {
            background: #e8690b;
        }
        
        .btn-reset {
            background: #6c757d;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
        }
        
        .btn-reset:hover {
            background: #5a6268;
        }
        
        .merged-status {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .merged-message {
            color: #856404;
            font-weight: 500;
            margin-bottom: 10px;
        }
        
        .confirmation-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .confirmation-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            max-width: 400px;
            text-align: center;
        }
        
        .confirmation-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #dc3545;
        }
        
        .confirmation-message {
            margin-bottom: 20px;
            color: #6c757d;
        }
        
        .confirmation-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .btn-confirm {
            background: #dc3545;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .btn-cancel {
            background: #6c757d;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .final-actions {
            display: flex;
            gap: 10px;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }
        
        .final-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
        }
        
        .btn-finish {
            background: #28a745;
            color: white;
        }
        
        .btn-finish:hover:not(:disabled) {
            background: #218838;
        }
        
        .btn-finish:disabled {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .btn-finish-close {
            background: #17a2b8;
            color: white;
        }
        
        .btn-finish-close:hover:not(:disabled) {
            background: #138496;
        }
        
        .btn-finish-close:disabled {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .btn-cancel {
            background: #6c757d;
            color: white;
        }
        
        .completion-message {
            text-align: center;
            padding: 40px;
            background: #d4edda;
            border-radius: 6px;
            color: #155724;
        }
        
        .completion-message h2 {
            color: #155724;
            margin-bottom: 10px;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="review-container">
        <div class="header">
            <div class="title" id="title">Custom Table Review System</div>
            <div class="progress" id="progress">Initializing...</div>
            
            <div class="navigation">
                <button class="nav-btn" id="prev-btn" onclick="previousTable()" disabled>‚Üê Previous</button>
                <button class="nav-btn" id="next-btn" onclick="nextTable()" disabled>Next ‚Üí</button>
                <button class="nav-btn" id="overview-btn" onclick="showOverview()">Overview</button>
            </div>
        </div>
        
        <div id="table-review-section">
            <div class="current-table" id="current-table">
                <div class="table-info">
                    <span>Table <span id="table-number">1</span> of <span id="total-tables">0</span></span>
                    <span class="table-hash" id="table-hash">hash</span>
                    <div class="status-display status-pending" id="table-status">Pending</div>
                </div>
                
                <div class="context-info">
                    <div class="context-item">
                        <div class="context-label">Found in versions:</div>
                        <div class="versions" id="versions-display"></div>
                    </div>
                    <div class="context-item">
                        <div class="context-label">Pages:</div>
                        <div id="pages-display"></div>
                    </div>
                    <div class="context-item">
                        <div class="context-label">PDF Documents:</div>
                        <div class="pdf-links" id="pdf-links"></div>
                    </div>
                    <div class="context-item">
                        <div class="context-label">Structure:</div>
                        <div id="structure-info"></div>
                    </div>
                </div>
                
                
                
                <div class="table-editor">
                    <div class="editor-header">
                        <div class="editor-title">Table Editor</div>
                        
                        <div class="editor-controls">
                            <!-- Header row checkbox -->
                            <label class="header-checkbox">
                                <input type="checkbox" id="has-header-row" onchange="toggleHeaderRow()">
                                Has header row
                            </label>
                            
                            <!-- Row operations -->
                            <div class="editor-control-group">
                                <label>Rows:</label>
                                <button class="compact-btn" onclick="addRowAbove()" title="Add row above selected cell">‚¨ÜÔ∏è+</button>
                                <button class="compact-btn" onclick="addRowBelow()" title="Add row below selected cell">‚¨áÔ∏è+</button>
                                <button class="compact-btn" onclick="removeRow()" title="Remove current row">üóëÔ∏è</button>
                            </div>
                            
                            <!-- Column operations -->
                            <div class="editor-control-group">
                                <label>Cols:</label>
                                <button class="compact-btn" onclick="addColumnLeft()" title="Add column left of selected cell">‚¨ÖÔ∏è+</button>
                                <button class="compact-btn" onclick="addColumnRight()" title="Add column right of selected cell">‚û°Ô∏è+</button>
                                <button class="compact-btn" onclick="removeColumn()" title="Remove current column">üóëÔ∏è</button>
                            </div>
                            
                            <!-- Table operations -->
                            <div class="editor-control-group">
                                <label>Table:</label>
                                <button class="compact-btn" onclick="mergeTable()" title="Merge with next table">‚ü± Merge</button>
                                <button class="compact-btn" onclick="skipTable()" title="Skip for now">‚Üí Skip</button>
                            </div>
                            
                            <!-- Reset button -->
                            <button class="btn-reset" onclick="resetTableStructure()" title="Reset to original structure">üîÑ Reset</button>
                        </div>
                    </div>
                    
                    <div id="table-container">
                        <!-- Table will be generated here -->
                    </div>
                </div>
                
                <!-- Table Status Control (moved below editor) -->
                <div class="table-status-control" id="status-control">
                    <label class="status-label">Table Status:</label>
                    <div class="radio-group" id="status-radio-group">
                        <label class="radio-option">
                            <div class="radio-option-header">
                                <input type="radio" name="table-status" value="undefined" checked onchange="updateTableStatus('undefined')">
                                <span class="radio-label">‚ùì Undefined</span>
                            </div>
                            <div class="radio-description">User must make a selection</div>
                        </label>
                        <label class="radio-option">
                            <div class="radio-option-header">
                                <input type="radio" name="table-status" value="confirmed_without_changes" onchange="updateTableStatus('confirmed_without_changes')">
                                <span class="radio-label">‚úÖ Confirmed without changes</span>
                            </div>
                            <div class="radio-description">Table is correctly converted, no editing needed</div>
                        </label>
                        <label class="radio-option">
                            <div class="radio-option-header">
                                <input type="radio" name="table-status" value="confirmed_with_changes" onchange="updateTableStatus('confirmed_with_changes')">
                                <span class="radio-label">‚úèÔ∏è Confirmed with changes</span>
                            </div>
                            <div class="radio-description">Table is a table, but edits are needed</div>
                        </label>
                        <label class="radio-option">
                            <div class="radio-option-header">
                                <input type="radio" name="table-status" value="rejected" onchange="updateTableStatus('rejected')">
                                <span class="radio-label">‚ùå Rejected</span>
                            </div>
                            <div class="radio-description">Not a table and should not be treated as such</div>
                        </label>
                    </div>
                </div>
                
                <!-- Merged Status Display (shown when table is merged) -->
                <div class="merged-status" id="merged-status" style="display: none;">
                    <div class="merged-message" id="merged-message">This table has been merged with a previous table.</div>
                    <button class="btn-unmerge" onclick="showUnmergeConfirmation()">Unmerge Table</button>
                </div>
                
            </div>
        </div>
        
        <div id="completion-section" class="hidden">
            <div class="completion-message">
                <h2>üéâ Review Complete!</h2>
                <p>All tables have been reviewed.</p>
                <p id="review-summary"></p>
            </div>
        </div>
        
        <div class="final-actions">
            <button class="final-btn btn-finish" id="finish-review-btn" onclick="finishReviewForLaw()" disabled>
                Finish Review for this Law
            </button>
            <button class="final-btn btn-finish-close" id="finish-close-btn" onclick="finishReviewAndClose()" disabled style="display: none;">
                Finish Review for this Law and Quit
            </button>
            <button class="final-btn btn-cancel" onclick="cancelReview()">
                Cancel Review
            </button>
            <button class="final-btn btn-cancel" id="cancel-quit-btn" onclick="cancelReviewAndQuit()" style="display: none;">
                Cancel Review and Quit
            </button>
        </div>
    </div>

    <script>
        // ====== GLOBAL STATE ======
        let lawData = null;
        let currentTableIndex = 0;
        let corrections = {};
        let tableData = {};
        let selectedCell = null; // Track currently selected cell for operations
        let reviewMode = 'single'; // 'single' or 'folder'
        
        // ====== INITIALIZATION ======
        
        function initReview(data) {
            console.log('üöÄ Initializing custom table review:', data);
            lawData = data;
            corrections = {};
            currentTableIndex = 0;
            
            // Load existing corrections if available
            if (data.existing_corrections) {
                corrections = { ...data.existing_corrections };
                console.log('üìã Loaded existing corrections:', Object.keys(corrections).length, 'tables');
                
                // Log correction details for debugging
                Object.entries(corrections).forEach(([hash, correction]) => {
                    console.log(`  - Table ${hash.substring(0, 8)}: ${correction.status}`);
                });
            }
            
            // Detect review mode from URL parameters or data
            const urlParams = new URLSearchParams(window.location.search);
            reviewMode = urlParams.get('mode') || data.review_mode || 'single';
            
            // Store progression info if available
            if (data.progression) {
                window.progressionInfo = data.progression;
                console.log('üìä Progression info:', progressionInfo);
            }
            
            document.getElementById('title').textContent = `Law ${data.law_id} - Table Review`;
            document.getElementById('total-tables').textContent = data.tables.length;
            
            // Show appropriate buttons based on review mode
            updateButtonVisibility();
            
            // Initialize table data storage
            data.tables.forEach(table => {
                // Use corrected structure if available, otherwise use original structure
                if (corrections[table.hash] && corrections[table.hash].corrected_structure) {
                    tableData[table.hash] = JSON.parse(JSON.stringify(corrections[table.hash].corrected_structure));
                    console.log(`üìã Using corrected structure for table ${table.hash.substring(0, 8)}`);
                } else {
                    tableData[table.hash] = JSON.parse(JSON.stringify(table.structure)); // Deep copy
                }
            });
            
            if (data.tables.length === 0) {
                showCompletion();
            } else {
                showTable(0);
            }
            
            updateNavigation();
            updateCompletionStatus();
            console.log('‚úÖ Custom review system initialized');
        }
        
        // ====== TABLE DISPLAY AND NAVIGATION ======
        
        function showTable(index) {
            if (index < 0 || index >= lawData.tables.length) return;
            
            currentTableIndex = index;
            const table = lawData.tables[index];
            
            console.log(`üìã Showing table ${index + 1}:`, table);
            
            // Update table info
            document.getElementById('table-number').textContent = index + 1;
            document.getElementById('table-hash').textContent = table.hash.substring(0, 12) + '...';
            
            // Update status
            const status = corrections[table.hash] ? corrections[table.hash].status : 'undefined';
            let displayStatus = status === 'undefined' ? 'pending' : status;
            
            // Check if merged into another table
            if (status === 'merged' && corrections[table.hash].merged_into) {
                displayStatus = `Merged into table ${corrections[table.hash].merged_into.substring(0, 8)}...`;
            }
            
            const statusEl = document.getElementById('table-status');
            statusEl.textContent = displayStatus;
            statusEl.className = `status-display status-${status === 'undefined' ? 'pending' : status}`;
            
            // Handle merged status display
            const statusControl = document.getElementById('status-control');
            const mergedStatus = document.getElementById('merged-status');
            const mergedMessage = document.getElementById('merged-message');
            
            if (status === 'merged' || status.startsWith('merged_with_')) {
                // Show merged status, hide radio controls
                statusControl.style.display = 'none';
                mergedStatus.style.display = 'block';
                if (corrections[table.hash] && corrections[table.hash].merged_into) {
                    mergedMessage.textContent = `This table has been merged with table ${corrections[table.hash].merged_into.substring(0, 8)}...`;
                } else {
                    mergedMessage.textContent = 'This table has been merged with a previous table.';
                }
            } else {
                // Show radio controls, hide merged status
                statusControl.style.display = 'block';
                mergedStatus.style.display = 'none';
                
                // Set radio button
                const radioStatus = status === 'pending' ? 'undefined' : status;
                const radioButtons = document.querySelectorAll('input[name="table-status"]');
                radioButtons.forEach(radio => {
                    radio.checked = radio.value === radioStatus;
                    radio.disabled = false;
                });
            }
            
            // Disable merge button if current table is merged or if there's no next table
            const mergeBtn = document.querySelector('button[onclick="mergeTable()"]');
            if (mergeBtn) {
                const hasNextTable = currentTableIndex < lawData.tables.length - 1;
                mergeBtn.disabled = status === 'merged' || !hasNextTable;
                mergeBtn.style.opacity = (status === 'merged' || !hasNextTable) ? '0.5' : '1';
                mergeBtn.title = !hasNextTable ? 'No next table to merge' : '';
            }
            
            // Update context info
            const versionsEl = document.getElementById('versions-display');
            versionsEl.innerHTML = table.found_in_versions
                .map(v => `<span class="version-badge">${v}</span>`)
                .join('');
            
            const pagesEl = document.getElementById('pages-display');
            pagesEl.textContent = Object.entries(table.pages)
                .map(([v, p]) => `v${v}: ${Array.isArray(p) ? p.join(', ') : p}`)
                .join(' | ');
            
            const pdfLinksEl = document.getElementById('pdf-links');
            // Use source_links if available, otherwise fallback to pdf_paths
            if (table.source_links) {
                pdfLinksEl.innerHTML = Object.entries(table.source_links)
                    .map(([v, link]) => link ? `<a href="${link}" class="pdf-link" target="_blank">View v${v} on zh.ch</a>` : '')
                    .filter(link => link)  // Remove empty links
                    .join('');
            } else {
                // Fallback to pdf_paths if source_links not available
                pdfLinksEl.innerHTML = Object.entries(table.pdf_paths)
                    .map(([v, path]) => `<a href="file://${path}" class="pdf-link" target="_blank">View v${v}</a>`)
                    .join('');
            }
            
            const structureEl = document.getElementById('structure-info');
            structureEl.textContent = `${table.structure.length} rows √ó ${table.structure[0] ? table.structure[0].length : 0} columns`;
            
            // Render table
            renderTable(table.hash);
            
            // Set correct editable state based on status
            const isEditingEnabled = status === 'confirmed_with_changes' || status === 'confirmed'; // backward compatibility
            setTableEditable(isEditingEnabled);
            
            // Update navigation
            updateNavigation();
            updateProgress();
        }
        
        // ====== TABLE RENDERING ======
        
        function renderTable(tableHash) {
            const checkbox = document.getElementById('has-header-row');
            const hasHeaderRow = checkbox ? checkbox.checked : hasActualHeaderRow(tableData[tableHash]);
            
            // If checkbox doesn't match auto-detection, sync it
            if (checkbox && !checkbox.checked && hasActualHeaderRow(tableData[tableHash])) {
                checkbox.checked = true;
            }
            
            renderTableWithHeaderSetting(tableHash, hasHeaderRow);
        }
        
        // Update cell data
        function updateCell(row, col, content) {
            const table = lawData.tables[currentTableIndex];
            if (!tableData[table.hash]) return;
            
            // Ensure structure exists
            while (tableData[table.hash].length <= row) {
                tableData[table.hash].push([]);
            }
            while (tableData[table.hash][row].length <= col) {
                tableData[table.hash][row].push('');
            }
            
            tableData[table.hash][row][col] = content;
            console.log(`üìù Updated cell [${row}][${col}] = "${content}"`);
            
            // Auto-mark as confirmed with changes when editing (if not already set)
            if (!corrections[table.hash] || corrections[table.hash].status === 'undefined') {
                // Set radio button to confirmed with changes
                const confirmedWithChangesRadio = document.querySelector('input[name="table-status"][value="confirmed_with_changes"]');
                if (confirmedWithChangesRadio) {
                    confirmedWithChangesRadio.checked = true;
                    updateTableStatus('confirmed_with_changes');
                }
            }
        }
        
        // Mark cell as modified visually
        function markModified(cell) {
            cell.classList.add('modified');
        }
        
        // ====== TABLE MANIPULATION ======
        function addRow() {
            const table = lawData.tables[currentTableIndex];
            const structure = tableData[table.hash];
            const columns = structure[0] ? structure[0].length : 1;
            
            structure.push(new Array(columns).fill(''));
            renderTable(table.hash);
            updateTableStructureWithoutStatusChange();
        }
        
        function addColumn() {
            const table = lawData.tables[currentTableIndex];
            const structure = tableData[table.hash];
            
            structure.forEach(row => row.push(''));
            renderTable(table.hash);
            updateTableStructureWithoutStatusChange();
        }
        
        function removeRow() {
            const table = lawData.tables[currentTableIndex];
            const structure = tableData[table.hash];
            
            if (structure.length > 1) {
                structure.pop();
                renderTable(table.hash);
                updateTableStructureWithoutStatusChange();
            }
        }
        
        function removeColumn() {
            const table = lawData.tables[currentTableIndex];
            const structure = tableData[table.hash];
            
            if (structure[0] && structure[0].length > 1) {
                structure.forEach(row => row.pop());
                renderTable(table.hash);
                updateTableStructureWithoutStatusChange();
            }
        }
        
        function updateTableStructureWithoutStatusChange() {
            const table = lawData.tables[currentTableIndex];
            
            // Update the corrected structure if table allows editing
            if (corrections[table.hash] && 
                (corrections[table.hash].status === 'confirmed_with_changes' || 
                 corrections[table.hash].status === 'confirmed')) { // backward compatibility
                corrections[table.hash].corrected_structure = tableData[table.hash];
                console.log(`üìù Updated table structure while maintaining editable status`);
            }
        }
        
        function resetTable() {
            const table = lawData.tables[currentTableIndex];
            tableData[table.hash] = JSON.parse(JSON.stringify(table.structure));
            renderTable(table.hash);
            
            // Reset status
            if (corrections[table.hash]) {
                corrections[table.hash].status = 'pending';
                delete corrections[table.hash].corrected_structure;
            }
            
            showTable(currentTableIndex); // Refresh display
        }
        
        // ====== TABLE STATUS MANAGEMENT ======
        function updateTableStatus(status) {
            const table = lawData.tables[currentTableIndex];
            
            if (status === 'undefined') {
                // Remove correction if set to undefined
                if (corrections[table.hash]) {
                    delete corrections[table.hash];
                }
                // Disable editing when undefined
                setTableEditable(false);
                console.log(`‚ùì Table ${table.hash} set to undefined`);
                
            } else if (status === 'confirmed_without_changes') {
                corrections[table.hash] = {
                    hash: table.hash,
                    status: 'confirmed_without_changes',
                    found_in_versions: table.found_in_versions,
                    pages: table.pages,
                    pdf_paths: table.pdf_paths,
                    source_links: table.source_links,
                    original_structure: table.structure
                    // No corrected_structure needed for this status
                };
                // Disable editing when confirmed without changes
                setTableEditable(false);
                console.log(`‚úÖ Confirmed table ${table.hash} without changes`);
                
            } else if (status === 'confirmed_with_changes') {
                corrections[table.hash] = {
                    hash: table.hash,
                    status: 'confirmed_with_changes',
                    found_in_versions: table.found_in_versions,
                    pages: table.pages,
                    pdf_paths: table.pdf_paths,
                    source_links: table.source_links,
                    original_structure: table.structure,
                    corrected_structure: tableData[table.hash]
                };
                // Enable editing when confirmed with changes
                setTableEditable(true);
                console.log(`‚úèÔ∏è Confirmed table ${table.hash} with changes enabled`);
                
            } else if (status === 'rejected') {
                corrections[table.hash] = {
                    hash: table.hash,
                    status: 'rejected',
                    found_in_versions: table.found_in_versions,
                    pages: table.pages,
                    pdf_paths: table.pdf_paths,
                    source_links: table.source_links,
                    reason: 'Rejected by user'
                };
                // Disable editing when rejected
                setTableEditable(false);
                console.log(`‚ùå Rejected table ${table.hash}`);
            }
            
            // Update status display
            const statusEl = document.getElementById('table-status');
            statusEl.textContent = status.replace(/_/g, ' ');
            statusEl.className = `status-display status-${status.replace(/_/g, '-')}`;
            
            // Update merge button state when status changes
            const mergeBtn = document.querySelector('button[onclick="mergeTable()"]');
            if (mergeBtn) {
                const hasNextTable = currentTableIndex < lawData.tables.length - 1;
                const isEditingEnabled = status === 'confirmed_with_changes' || status === 'confirmed';
                // Disable merge button if: no next table, current status is not editable, or table is merged
                mergeBtn.disabled = !hasNextTable || !isEditingEnabled || status === 'merged';
                mergeBtn.style.opacity = mergeBtn.disabled ? '0.5' : '1';
                mergeBtn.title = !hasNextTable ? 'No next table to merge' : (!isEditingEnabled ? 'Select "Confirmed with changes" to enable merging' : '');
            }
            
            updateProgress();
            updateCompletionStatus();
        }
        
        // ====== COMPLETION VALIDATION AND BUTTON MANAGEMENT ======
        
        function validateAllTablesDecided() {
            /**
             * Check if all tables have been decided (no undefined status).
             * Returns {isComplete: boolean, undecidedHashes: string[]}
             */
            const undecidedHashes = [];
            
            for (const table of lawData.tables) {
                const tableHash = table.hash;
                const correction = corrections[tableHash];
                
                if (!correction || correction.status === 'undefined') {
                    undecidedHashes.push(tableHash);
                }
            }
            
            return {
                isComplete: undecidedHashes.length === 0,
                undecidedHashes: undecidedHashes
            };
        }
        
        function updateButtonVisibility() {
            /**
             * Show/hide buttons based on review mode
             */
            const finishBtn = document.getElementById('finish-review-btn');
            const finishCloseBtn = document.getElementById('finish-close-btn');
            const cancelQuitBtn = document.getElementById('cancel-quit-btn');
            
            if (reviewMode === 'folder') {
                // Show additional buttons for folder mode
                finishBtn.style.display = 'inline-block';
                finishCloseBtn.style.display = 'inline-block';
                cancelQuitBtn.style.display = 'inline-block';
                finishBtn.textContent = 'Finish Review for this Law';
            } else {
                // Show only finish button for single law mode
                finishBtn.style.display = 'inline-block';
                finishCloseBtn.style.display = 'none';
                cancelQuitBtn.style.display = 'none';
                finishBtn.textContent = 'Finish Review for this Law';
            }
        }
        
        function updateCompletionStatus() {
            /**
             * Update button states based on completion status
             */
            const validation = validateAllTablesDecided();
            const finishBtn = document.getElementById('finish-review-btn');
            const finishCloseBtn = document.getElementById('finish-close-btn');
            
            // Enable/disable buttons based on completion
            finishBtn.disabled = !validation.isComplete;
            finishCloseBtn.disabled = !validation.isComplete;
            
            // Update button tooltips
            if (!validation.isComplete) {
                const message = `Please decide on ${validation.undecidedHashes.length} remaining table(s)`;
                finishBtn.title = message;
                finishCloseBtn.title = message;
            } else {
                finishBtn.title = '';
                finishCloseBtn.title = '';
            }
            
            console.log(`üìä Completion status: ${validation.isComplete ? 'Complete' : `${validation.undecidedHashes.length} tables undecided`}`);
        }
        
        function finishReviewForLaw() {
            /**
             * Finish review for current law and proceed to next (folder mode) or close (single mode)
             */
            const validation = validateAllTablesDecided();
            
            if (!validation.isComplete) {
                // Buttons are disabled when validation fails, so this shouldn't happen
                console.log(`Validation failed: ${validation.undecidedHashes.length} table(s) still need decisions`);
                return;
            }
            
            // Save corrections and proceed to next law
            saveCorrectionsAndProceed('next');
        }
        
        function finishReviewAndClose() {
            /**
             * Finish review for current law and close browser (folder mode only)
             */
            const validation = validateAllTablesDecided();
            
            if (!validation.isComplete) {
                // Buttons are disabled when validation fails, so this shouldn't happen
                console.log(`Validation failed: ${validation.undecidedHashes.length} table(s) still need decisions`);
                return;
            }
            
            // Save corrections and quit the entire process
            saveCorrectionsAndProceed('quit');
        }
        
        function saveCorrectionsAndProceed(action) {
            /**
             * Save corrections and take specified action
             * @param {string} action - 'next', 'close', or 'complete'
             */
            // Update all edited tables
            Object.keys(corrections).forEach(hash => {
                if (corrections[hash].status === 'confirmed_with_changes') {
                    corrections[hash].corrected_structure = tableData[hash];
                }
            });
            
            // Prepare request data
            const requestData = {
                corrections: corrections,
                action: action,
                law_id: lawData.law_id
            };
            
            fetch('/save-corrections', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log('‚úÖ Corrections saved successfully');
                    
                    if (action === 'next') {
                        // Silent auto-progression to next law - no popups
                        console.log('‚úÖ Review complete, proceeding to next law');
                        window.close();
                        
                    } else if (action === 'quit') {
                        // User chose to quit - end the process
                        console.log('‚úÖ Review complete, ending process');
                        window.close();
                        
                    } else {
                        // Single law completed or unknown action
                        showSingleLawCompleted();
                    }
                } else {
                    throw new Error(data.error || 'Save failed');
                }
            })
            .catch(error => {
                console.error('Server save failed:', error);
                alert('‚ùå Failed to save corrections: ' + error.message + '\n\nPlease try again or contact support.');
            });
        }
        
        function showAllLawsCompleted() {
            /**
             * Show completion message for all laws in folder
             */
            document.getElementById('table-review-section').classList.add('hidden');
            document.getElementById('completion-section').classList.remove('hidden');
            
            document.querySelector('.completion-message h2').textContent = 'üéâ All Laws Completed!';
            document.getElementById('review-summary').textContent = 'All laws in this folder have been reviewed.';
            
            // Close browser automatically after a brief delay
            setTimeout(() => {
                window.close();
                // Fallback if close doesn't work
                setTimeout(() => {
                    alert('‚úÖ All reviews completed! You can close this tab.');
                }, 1000);
            }, 2000);
        }
        
        function showSingleLawCompleted() {
            /**
             * Show completion message for single law
             */
            document.getElementById('table-review-section').classList.add('hidden');
            document.getElementById('completion-section').classList.remove('hidden');
            
            document.querySelector('.completion-message h2').textContent = 'üéâ Law Review Complete!';
            document.getElementById('review-summary').textContent = `Law ${lawData.law_id} has been reviewed.`;
            
            // Close browser automatically after a brief delay
            setTimeout(() => {
                window.close();
                // Fallback if close doesn't work
                setTimeout(() => {
                    alert('‚úÖ Review completed! You can close this tab.');
                }, 1000);
            }, 2000);
        }
        
        // ====== END COMPLETION VALIDATION ======
        
        // ====== TABLE EDITING CONTROL ======
        function setTableEditable(editable) {
            const cells = document.querySelectorAll('#editable-table td[contenteditable], #editable-table th[contenteditable]');
            cells.forEach(cell => {
                cell.contentEditable = editable;
                if (editable) {
                    cell.style.cursor = 'text';
                    cell.style.backgroundColor = '';
                } else {
                    cell.style.cursor = 'default';
                    cell.style.backgroundColor = '#f5f5f5';
                }
            });
            
            // Clear any existing selection when disabling editing
            if (!editable) {
                document.querySelectorAll('.selected-cell').forEach(c => c.classList.remove('selected-cell'));
                selectedCell = null;
            }
            
            // Enable/disable table manipulation buttons
            const tableButtons = document.querySelectorAll('.editor-controls .compact-btn');
            tableButtons.forEach(btn => {
                btn.disabled = !editable;
                btn.style.opacity = editable ? '1' : '0.5';
            });
        }
        
        function markTableAsEdited() {
            const table = lawData.tables[currentTableIndex];
            corrections[table.hash] = {
                hash: table.hash,
                status: 'edited',
                found_in_versions: table.found_in_versions,
                pages: table.pages,
                pdf_paths: table.pdf_paths,
                original_structure: table.structure,
                corrected_structure: tableData[table.hash]
            };
            
            showTable(currentTableIndex);
        }
        
        // ====== SPECIAL TABLE OPERATIONS ======
        
        function mergeTable() {
            const table = lawData.tables[currentTableIndex];
            const nextTableIndex = currentTableIndex + 1;
            
            // Check if there's a next table to merge
            if (nextTableIndex >= lawData.tables.length) {
                alert('No next table available to merge');
                return;
            }
            
            const nextTable = lawData.tables[nextTableIndex];
            
            // Mark current table as confirmed with changes (since we're editing it)
            corrections[table.hash] = {
                hash: table.hash,
                status: 'confirmed_with_changes',
                found_in_versions: table.found_in_versions,
                pages: table.pages,
                pdf_paths: table.pdf_paths,
                source_links: table.source_links,
                original_structure: table.structure,
                corrected_structure: tableData[table.hash],
                merged_with: nextTable.hash
            };
            
            // Mark next table as merged
            corrections[nextTable.hash] = {
                hash: nextTable.hash,
                status: `merged_with_${table.hash}`,
                found_in_versions: nextTable.found_in_versions,
                pages: nextTable.pages,
                merged_into: table.hash,
                reason: 'Merged into previous table'
            };
            
            // Append next table's data to current table
            const currentData = tableData[table.hash];
            const nextData = tableData[nextTable.hash] || nextTable.structure;
            
            // Determine target column count (use current table's column count)
            const targetCols = currentData[0] ? currentData[0].length : (nextData[0] ? nextData[0].length : 2);
            
            // Add a separator row with correct column count
            const separatorRow = new Array(targetCols).fill('');
            separatorRow[0] = '--- Merged from next table ---';
            currentData.push(separatorRow);
            
            // Append all rows from next table, adjusting column count
            nextData.forEach(row => {
                const newRow = [];
                for (let i = 0; i < targetCols; i++) {
                    newRow.push(row[i] || '');
                }
                currentData.push(newRow);
            });
            
            // Update the corrected structure
            corrections[table.hash].corrected_structure = currentData;
            
            // Re-render the table
            renderTable(table.hash);
            
            // Set radio button to confirmed with changes
            const confirmedWithChangesRadio = document.querySelector('input[name="table-status"][value="confirmed_with_changes"]');
            if (confirmedWithChangesRadio) {
                confirmedWithChangesRadio.checked = true;
            }
            setTableEditable(true);
            
            console.log(`‚ü± Merged table ${nextTable.hash} into ${table.hash}`);
            updateProgress();
            updateCompletionStatus();
        }
        
        function skipTable() {
            // Just move to next without making changes
            nextTable();
        }
        
        // ====== NAVIGATION ======
        function previousTable() {
            if (currentTableIndex > 0) {
                showTable(currentTableIndex - 1);
            }
        }
        
        function nextTable() {
            if (currentTableIndex < lawData.tables.length - 1) {
                showTable(currentTableIndex + 1);
            } else {
                showCompletion();
            }
        }
        
        function updateNavigation() {
            document.getElementById('prev-btn').disabled = currentTableIndex === 0;
            document.getElementById('next-btn').disabled = currentTableIndex >= lawData.tables.length - 1;
        }
        
        function updateProgress() {
            const completed = Object.keys(corrections).length;
            const total = lawData.tables.length;
            document.getElementById('progress').textContent = 
                `Progress: ${completed}/${total} tables reviewed (${Math.round(completed/total*100)}%)`;
        }
        
        function showOverview() {
            let summary = 'Review Summary:\n\n';
            lawData.tables.forEach((table, index) => {
                const status = corrections[table.hash] ? corrections[table.hash].status : 'pending';
                summary += `Table ${index + 1} (${table.hash.substring(0, 8)}...): ${status}\n`;
            });
            alert(summary);
        }
        
        // ====== PROGRESS AND OVERVIEW ======
        
        function showCompletion() {
            document.getElementById('table-review-section').classList.add('hidden');
            document.getElementById('completion-section').classList.remove('hidden');
            
            const completed = Object.keys(corrections).length;
            const total = lawData.tables.length;
            const summary = `Reviewed ${completed} out of ${total} tables.`;
            document.getElementById('review-summary').textContent = summary;
        }
        
        // Legacy save function - redirects to new completion flow
        function saveCorrections() {
            console.log('‚ö†Ô∏è Legacy saveCorrections called - redirecting to completion flow');
            finishReviewForLaw();
        }
        
        // ====== LEGACY AND UTILITY FUNCTIONS ======
        
        function exportCorrections() {
            // Update corrections with current table data
            Object.keys(corrections).forEach(hash => {
                if (corrections[hash].status === 'edited') {
                    corrections[hash].corrected_structure = tableData[hash];
                }
            });
            
            const dataStr = JSON.stringify(corrections, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
            
            const link = document.createElement('a');
            link.setAttribute('href', dataUri);
            link.setAttribute('download', `${lawData.law_id}-corrections.json`);
            link.click();
        }
        
        function cancelReview() {
            // Prevent multiple executions
            if (window.cancelInProgress) {
                return;
            }
            
            let action, message;
            
            if (reviewMode === 'folder') {
                // In folder mode, cancel current law and move to next
                action = 'cancel_next';
                message = 'Cancel review for this law? Unsaved changes will be lost and the next law will be opened.';
            } else {
                // In single mode, cancel and quit
                action = 'cancel';
                message = 'Cancel review? All unsaved changes will be lost.';
            }
            
            if (confirm(message)) {
                window.cancelInProgress = true;
                console.log('‚ùå Review cancelled by user with action:', action);
                
                // Send cancel action to backend
                fetch('/save-corrections', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        corrections: {},
                        action: action,
                        law_id: lawData.law_id
                    })
                })
                .finally(() => {
                    window.close();
                });
            }
        }
        
        function cancelReviewAndQuit() {
            // Prevent multiple executions
            if (window.cancelInProgress) {
                return;
            }
            
            if (confirm('Cancel review and quit entire process? All unsaved changes will be lost.')) {
                window.cancelInProgress = true;
                console.log('‚ùå Review cancelled and quit by user');
                
                // Send cancel and quit action to backend
                fetch('/save-corrections', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        corrections: {},
                        action: 'cancel_quit',
                        law_id: lawData.law_id
                    })
                })
                .finally(() => {
                    window.close();
                });
            }
        }
        
        // ====== DATA LOADING ======
        function loadData() {
            fetch('/data.json')
                .then(response => response.json())
                .then(data => {
                    console.log('üì• Loaded data from server');
                    initReview(data);
                })
                .catch(error => {
                    console.warn('Failed to load from server:', error);
                    
                    // Fallback to sample data
                    const sampleData = {
                        law_id: '170.4',
                        tables: [{
                            hash: 'sample123',
                            found_in_versions: ['118'],
                            pages: {'118': [2]},
                            pdf_paths: {'118': '/sample.pdf'},
                            structure: [
                                ['Header 1', 'Header 2'],
                                ['Cell 1', 'Cell 2'],
                                ['Cell 3', 'Cell 4']
                            ]
                        }]
                    };
                    
                    console.log('üì• Using sample data');
                    initReview(sampleData);
                });
        }
        
        // ====== ADVANCED TABLE OPERATIONS ======
        
        // Track cell selection for operations
        function selectCell(cell, row, col) {
            // Check if table is in editable state
            const table = lawData.tables[currentTableIndex];
            const status = corrections[table.hash] ? corrections[table.hash].status : 'undefined';
            
            // Only allow selection if status is 'confirmed_with_changes' or legacy 'confirmed'
            if (status !== 'confirmed_with_changes' && status !== 'confirmed') {
                return; // Don't allow selection
            }
            
            // Remove previous selection
            document.querySelectorAll('.selected-cell').forEach(c => c.classList.remove('selected-cell'));
            
            // Add selection to current cell
            cell.classList.add('selected-cell');
            selectedCell = { element: cell, row: row, col: col };
            
            console.log(`üìç Selected cell [${row}][${col}]`);
        }
        
        // Check if table has actual header row (heuristic detection)
        function hasActualHeaderRow(structure) {
            if (!structure || structure.length === 0) return false;
            
            const firstRow = structure[0];
            const secondRow = structure.length > 1 ? structure[1] : null;
            
            // If no second row, assume first row is data
            if (!secondRow) return false;
            
            // Simple heuristic: if first row cells are generally shorter and more title-like
            // compared to second row, treat as header
            let headerScore = 0;
            for (let i = 0; i < Math.min(firstRow.length, secondRow.length); i++) {
                const firstCell = (firstRow[i] || '').trim();
                const secondCell = (secondRow[i] || '').trim();
                
                // Headers tend to be shorter and less detailed
                if (firstCell.length > 0 && firstCell.length < secondCell.length * 0.7) {
                    headerScore++;
                }
                
                // Headers often don't contain numbers or detailed text
                if (firstCell.length > 0 && !/\d{2,}/.test(firstCell) && /\d{2,}/.test(secondCell)) {
                    headerScore++;
                }
            }
            
            // If more than half the columns suggest header behavior, treat as header
            return headerScore > firstRow.length * 0.4;
        }
        
        // Toggle header row
        function toggleHeaderRow() {
            const checkbox = document.getElementById('has-header-row');
            const tableHash = lawData.tables[currentTableIndex].hash;
            
            // Force re-render table with new header setting based on checkbox state
            renderTableWithHeaderSetting(tableHash, checkbox.checked);
            
            console.log(checkbox.checked ? '‚úÖ Header row enabled' : '‚ùå Header row disabled');
        }
        
        // Render table with explicit header setting
        function renderTableWithHeaderSetting(tableHash, forceHeaderEnabled) {
            const container = document.getElementById('table-container');
            const structure = tableData[tableHash];
            
            if (!structure || structure.length === 0) {
                container.innerHTML = '<p>No table data available</p>';
                return;
            }
            
            // Use forced header setting instead of auto-detection
            const hasHeaderRow = forceHeaderEnabled;
            
            let html = '<table class="custom-table" id="editable-table">';
            
            // Render rows
            for (let i = 0; i < structure.length; i++) {
                html += '<tr>';
                for (let j = 0; j < structure[i].length; j++) {
                    const cellContent = structure[i][j] || '';
                    const isHeader = hasHeaderRow && i === 0;
                    const tag = isHeader ? 'th' : 'td';
                    const headerClass = isHeader ? 'class="header-enabled"' : '';
                    
                    if (isHeader) {
                        html += `<${tag} contenteditable="true" ${headerClass}
                                     onclick="selectCell(this, ${i}, ${j})" 
                                     data-row="${i}" data-col="${j}"
                                     onblur="updateCell(${i}, ${j}, this.textContent)"
                                     oninput="markModified(this)">${cellContent}</${tag}>`;
                    } else {
                        html += `<td contenteditable="true" 
                                    data-row="${i}" 
                                    data-col="${j}"
                                    onclick="selectCell(this, ${i}, ${j})"
                                    onblur="updateCell(${i}, ${j}, this.textContent)"
                                    oninput="markModified(this)">${cellContent}</td>`;
                    }
                }
                html += '</tr>';
            }
            
            html += '</table>';
            container.innerHTML = html;
            
            console.log(`‚úÖ Rendered table ${tableHash} with ${structure.length} rows, forced header: ${hasHeaderRow}`);
        }
        
        // Add row above selected cell
        function addRowAbove() {
            const table = lawData.tables[currentTableIndex];
            const currentData = tableData[table.hash];
            let targetRow = 0;
            
            if (selectedCell) {
                targetRow = selectedCell.row;
            } else {
                // If no cell selected, default to adding at top
                targetRow = 0;
            }
            
            // Create new empty row
            const colCount = currentData[0] ? currentData[0].length : 2;
            const newRow = new Array(colCount).fill('');
            
            // Insert row
            currentData.splice(targetRow, 0, newRow);
            
            // Re-render table and maintain selection
            renderTable(table.hash);
            
            // Reselect cell at same position (now shifted down)
            if (selectedCell) {
                const newCell = document.querySelector(`[data-row="${targetRow + 1}"][data-col="${selectedCell.col}"]`);
                if (newCell) {
                    selectCell(newCell, targetRow + 1, selectedCell.col);
                }
            }
            
            // Auto-mark as confirmed with changes
            autoMarkAsConfirmedWithChanges();
            
            console.log(`‚ûï Added row above row ${targetRow}`);
        }
        
        // Add row below selected cell
        function addRowBelow() {
            const table = lawData.tables[currentTableIndex];
            const currentData = tableData[table.hash];
            let targetRow = currentData.length;
            
            if (selectedCell) {
                targetRow = selectedCell.row + 1;
            } else {
                // If no cell selected, default to adding at bottom
                targetRow = currentData.length;
            }
            
            // Create new empty row
            const colCount = currentData[0] ? currentData[0].length : 2;
            const newRow = new Array(colCount).fill('');
            
            // Insert row
            currentData.splice(targetRow, 0, newRow);
            
            // Re-render table and maintain selection
            renderTable(table.hash);
            
            // Reselect cell at same position
            if (selectedCell) {
                const newCell = document.querySelector(`[data-row="${selectedCell.row}"][data-col="${selectedCell.col}"]`);
                if (newCell) {
                    selectCell(newCell, selectedCell.row, selectedCell.col);
                }
            }
            
            // Auto-mark as confirmed with changes
            autoMarkAsConfirmedWithChanges();
            
            console.log(`‚ûï Added row below row ${selectedCell ? selectedCell.row : 'end'}`);
        }
        
        // Remove current row
        function removeRow() {
            const table = lawData.tables[currentTableIndex];
            const currentData = tableData[table.hash];
            
            if (!selectedCell) {
                // If no cell selected, remove last row
                if (currentData.length <= 1) {
                    alert('Cannot remove the last row');
                    return;
                }
                currentData.splice(currentData.length - 1, 1);
                renderTable(table.hash);
                autoMarkAsConfirmedWithChanges();
                console.log('üóëÔ∏è Removed last row');
                return;
            }
            
            const targetRow = selectedCell.row;
            
            if (currentData.length <= 1) {
                alert('Cannot remove the last row');
                return;
            }
            
            // Remove row
            currentData.splice(targetRow, 1);
            
            // Re-render table
            renderTable(table.hash);
            
            // Try to reselect a nearby cell
            let newRow = Math.min(targetRow, currentData.length - 1);
            const newCell = document.querySelector(`[data-row="${newRow}"][data-col="${selectedCell.col}"]`);
            if (newCell) {
                selectCell(newCell, newRow, selectedCell.col);
            } else {
                selectedCell = null;
            }
            
            // Auto-mark as confirmed with changes
            autoMarkAsConfirmedWithChanges();
            
            console.log(`üóëÔ∏è Removed row ${targetRow}`);
        }
        
        // Add column left of selected cell
        function addColumnLeft() {
            const table = lawData.tables[currentTableIndex];
            const currentData = tableData[table.hash];
            let targetCol = 0;
            
            if (selectedCell) {
                targetCol = selectedCell.col;
            } else {
                // If no cell selected, default to adding at left
                targetCol = 0;
            }
            
            // Add column to each row
            currentData.forEach(row => {
                row.splice(targetCol, 0, '');
            });
            
            // Re-render table and maintain selection
            renderTable(table.hash);
            
            // Reselect cell at new position (shifted right)
            if (selectedCell) {
                const newCell = document.querySelector(`[data-row="${selectedCell.row}"][data-col="${targetCol + 1}"]`);
                if (newCell) {
                    selectCell(newCell, selectedCell.row, targetCol + 1);
                }
            }
            
            // Auto-mark as confirmed with changes
            autoMarkAsConfirmedWithChanges();
            
            console.log(`‚ûï Added column left of column ${targetCol}`);
        }
        
        // Add column right of selected cell
        function addColumnRight() {
            const table = lawData.tables[currentTableIndex];
            const currentData = tableData[table.hash];
            let targetCol = currentData[0] ? currentData[0].length : 0;
            
            if (selectedCell) {
                targetCol = selectedCell.col + 1;
            } else {
                // If no cell selected, default to adding at right
                targetCol = currentData[0] ? currentData[0].length : 0;
            }
            
            // Add column to each row
            currentData.forEach(row => {
                row.splice(targetCol, 0, '');
            });
            
            // Re-render table and maintain selection
            renderTable(table.hash);
            
            // Reselect cell at same position
            if (selectedCell) {
                const newCell = document.querySelector(`[data-row="${selectedCell.row}"][data-col="${selectedCell.col}"]`);
                if (newCell) {
                    selectCell(newCell, selectedCell.row, selectedCell.col);
                }
            }
            
            // Auto-mark as confirmed with changes
            autoMarkAsConfirmedWithChanges();
            
            console.log(`‚ûï Added column right of column ${selectedCell ? selectedCell.col : 'end'}`);
        }
        
        // Remove current column
        function removeColumn() {
            if (!selectedCell) {
                alert('Please select a cell first');
                return;
            }
            
            const table = lawData.tables[currentTableIndex];
            const currentData = tableData[table.hash];
            const targetCol = selectedCell.col;
            
            if (currentData[0] && currentData[0].length <= 1) {
                alert('Cannot remove the last column');
                return;
            }
            
            // Remove column from each row
            currentData.forEach(row => {
                row.splice(targetCol, 1);
            });
            
            // Clear selection
            selectedCell = null;
            
            // Re-render table
            renderTable(table.hash);
            
            // Auto-mark as confirmed with changes
            autoMarkAsConfirmedWithChanges();
            
            console.log(`üóëÔ∏è Removed column ${targetCol}`);
        }
        
        // Auto-mark table as confirmed with changes when editing
        function autoMarkAsConfirmedWithChanges() {
            if (!corrections[lawData.tables[currentTableIndex].hash] || 
                corrections[lawData.tables[currentTableIndex].hash].status === 'undefined') {
                
                const confirmedWithChangesRadio = document.querySelector('input[name="table-status"][value="confirmed_with_changes"]');
                if (confirmedWithChangesRadio) {
                    confirmedWithChangesRadio.checked = true;
                    updateTableStatus('confirmed_with_changes');
                }
            }
        }
        
        // ====== UNMERGE FUNCTIONALITY ======
        
        function showUnmergeConfirmation() {
            const modal = document.getElementById('unmerge-modal');
            modal.style.display = 'flex';
        }
        
        function hideUnmergeConfirmation() {
            const modal = document.getElementById('unmerge-modal');
            modal.style.display = 'none';
        }
        
        function confirmUnmerge() {
            const table = lawData.tables[currentTableIndex];
            const tableHash = table.hash;
            
            // Remove the correction (reset to undefined)
            if (corrections[tableHash]) {
                delete corrections[tableHash];
            }
            
            // Hide modal
            hideUnmergeConfirmation();
            
            // Refresh display - this will also update the status
            showTable(currentTableIndex);
            
            console.log(`Table ${tableHash} has been unmerged and reset to undefined status`);
        }
        
        // ====== RESET FUNCTIONALITY ======
        
        function resetTableStructure() {
            const table = lawData.tables[currentTableIndex];
            const tableHash = table.hash;
            
            // Reset tableData to original structure
            tableData[tableHash] = JSON.parse(JSON.stringify(table.structure));
            
            // Re-render the table with original structure
            renderTable(tableHash);
            
            // Update corrections to remove any structural changes
            if (corrections[tableHash]) {
                corrections[tableHash].corrected_structure = JSON.parse(JSON.stringify(table.structure));
            }
            
            console.log('Table structure reset to original');
        }
        
        // ====== INITIALIZATION AND EVENT HANDLERS ======
        
        // Initialize system when page loads
        document.addEventListener('DOMContentLoaded', loadData);
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        previousTable();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        nextTable();
                        break;
                    case 's':
                        e.preventDefault();
                        saveCorrections();
                        break;
                }
            }
        });
    </script>
    
    <!-- Unmerge Confirmation Modal -->
    <div class="confirmation-modal" id="unmerge-modal">
        <div class="confirmation-content">
            <div class="confirmation-title">‚ö†Ô∏è Confirm Unmerge</div>
            <div class="confirmation-message">
                Are you sure you want to unmerge this table? This action will restore the table to its original state and allow you to make a new decision.
            </div>
            <div class="confirmation-buttons">
                <button class="btn-cancel" onclick="hideUnmergeConfirmation()">Cancel</button>
                <button class="btn-confirm" onclick="confirmUnmerge()">Unmerge</button>
            </div>
        </div>
    </div>
</body>
</html>